关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能处于等待状态，前提是多个线程访问的是同一个对象。但如果多个线程访问多个对象，也就是每个线程访问自己所属的业务对象（上面的示例就是这种情况），则JVM会创建多个锁，不存在锁争抢的情况。

另外，更具体地讲，由于本示例创建了两个业务对象，所以产生两份实例变量，每个线程访问自己的实例变量，所以加不加synchronized关键字都是线程安全的。